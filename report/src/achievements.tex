\chapter{Contributions}\label{chap:contributions}

All the work I have done during this internship is related to the \gls{pfw},
which was briefly presented in section \ref{sec:parameter-framework}.
I had two major directions during my internship:
\begin{itemize}
    \item Delivering new features for Intel and its customers.
        I have submitted more than \emph{80 patchs} to the Intel codebase, which are now used by its customers.
    \item Open-source the \gls{pfw} to give it some weight in the middleware community.
        For doing that, I had to change some code within the \gls{pfw}.
        Today, I am in the top five contributors on GitHub as shown on figure \ref{fig:githubContrib} below (My nickname is \emph{Makohoek}).
        \begin{figureGraphics}{Top contributors on the Parameter-framework core}{fig:githubContrib}
            \includegraphics[width=\textwidth]{./src/img/statsGitHub.png}
        \end{figureGraphics}
\end{itemize}

% {{{1
\section{New features for Intel and its customers}

% {{{2
\subsection{XML validation at build time}

For our Intel Audio \gls{hal}, we have a lot of structure files. More than one hundred.
There a more than 40 000 lines of \gls{xml} structure files.
The writing of those structure files is done by human beings. Given the fact
that humans can make mistakes, there is \emph{no guarantee} that those structure files are semantically correct.
Furthermore, the \gls{pfw} expects that the files which are given no not contain any mistake.

An example can be that someone forgot to specify the \emph{size} attribute of a parameter.
In that case, the default size is $0$. Let's imagine we are computing a result as showed in figure \ref{fig:runtimeerror}.

\begin{figureGraphics}{Error example due to a bad parameter size}{fig:runtimeerror}
    $result = \dfrac{a*k}{size}$
    \vspace{0.3cm}
\end{figureGraphics}

In that case we have a run-time error due to a \emph{division by zero}. This is only one possible consequence of bad structure files.
This kind of problem should be detected when we are building our system, not at run-time. Having those problems at
run-time is far too time-consuming and thus far too expensive.

In the next sections we will see how to detect those problems at build time.

\subsubsection{A language for validating XML files}

To validate \gls{xml} files, we use \gls{xsd} files.
Those are describing what is allowed/prohibited within an \gls{xml} element. For example, the \emph{size} attribute is
\emph{mandatory} for an Integer parameter.
Listing \ref{lst:xsd} shows a snippet illustrating that example \gls{xsd} file:

\begin{code}[language=XML, caption=XSD rules for an Integer parameter, label=lst:xsd]
<xs:attributeGroup name="IntegerParameterAttributes">
    <xs:attribute name="Size" type="SizeType" use="required"/>
    <xs:attribute name="Min" type="xs:integer" use="optional"/>
    <xs:attribute name="Max" type="xs:integer" use="optional"/>
    <xs:attribute name="Signed" type="xs:boolean" use="optional" default="false"/>
</xs:attributeGroup>
\end{code}

With that knowledge in mind, I decided to write a \gls{python} tool to detect the possible errors in the existing structure files.

\subsubsection{A tool to validate XML}
To validate \gls{xml} with \gls{xsd} files, several tools exists already. The most widely used on linux is the \lstinline{xmllint} utility.
This works very well but is limited to one file per usage. The script I wrote in \gls{python} was able to have two directories as input and check
recursively every file.
This tool highlighted that there were more than \emph{500 errors} within the hundred files.

The problem with this \gls{python} script is that it did \emph{not use standard} \gls{python} libraries.
We needed a more robust solution which was integrated into the build system without using external libraries.

\subsubsection{Build process}
To understand how the robust solution is implemented, we need to have a look at the build process around the \gls{pfw}.

During the build process, we are translating settings files from a special format (which was shown in \ref{lst:pfwsettings}) into \gls{xml}.
That special format, which is called \emph{.pfw language}, is used for rule based
description. Those are translated into \gls{xml} files during the build via a
specific make target.  In order to generate those \gls{xml} files, we also need
the information of the structure files, which are written by the integration
engineers as described in previous subsection.

To generate those files, we rely on a toolset we call \emph{HostDomainGenerator}.
The figure \ref{fig:build-process} shows how it works:

\begin{figureGraphics}{Xml generation build process}{fig:build-process}
    \includegraphics[height=0.4\textheight]{./src/img/build-generation.pdf}
\end{figureGraphics}

\begin{itemize}
    \item The \emph{.pfw} files are parsed via a set of scripts and translated into \gls{pfw} commands.
    \item Those commands are sent to a special \gls{pfw} instance which was started for this purpose only.
    \item After that, the \gls{pfw} exports the rules which were created previously and dumps it into a settings \gls{xml} file.
    \item Those \emph{settings} and \emph{structure} files are then stored on the smartphone or the tablet in \lstinline{/etc/}.
\end{itemize}

In this build process, we have to display errors when detecting \gls{xml} files which are not compliant with the rules from the
\gls{xsd} files.

\subsubsection{Xml checker}

Since we wanted a more robust solution, it was finally done within the \gls{pfw} itself.
In fact, the parameter-framework already had some code to check \gls{xml} validity. It was not
finished and I had to complete it.

When that was done, I had to integrate the feature within the \lstinline{HostDomainGenerator} tool.
Figure \ref{fig:build-process-reworked} shows the final implementation.

\begin{figureGraphics}{Xml generation build process with validity check}{fig:build-process-reworked}
    \includegraphics[height=0.5\textheight]{./src/img/build-generation-after.pdf}
\end{figureGraphics}

With the difference to the solution showed in figure \ref{fig:build-process}, here we:
\begin{itemize}
    \item Give \gls{xsd} files towards the \lstinline{hostDomainGenerator} tool.
    \item Those are forwarded to the \gls{pfw}, which validates the \emph{structure} files before receiving the special commands.
    \item If the checks fail, it aborts the build.
    \item Otherwise, it receives dumps the \emph{settings} file as usual.
\end{itemize}

\subsubsection{Outcome}
In the end, this solution is widely used at Intel now. Every error described by the \gls{xsd} rules are removed.
In a matter of two weeks, the integration team was able to clean up more than 500 errors from the \gls{xml} structure files.
Moreover, it is impossible nowadays to let new validation errors go trough, since the system would not build.


% {{{2
\subsection{Multi-variant initial support}
\subsubsection{Context}
Intel has a various number of platforms for smarphones and tablets, which have different hardware specifications.
Every platform also haves minor hardware variances.
For example, there is a platform with two hardware variants: the audio architecture is not the same.
The architecture can for instance differ in a codec. Each of those different combinations is called a \emph{variant}.

An customer's requirement was to be able to have one single package for the Intel Audio \gls{hal} which works on every variant.
With this concern in mind, we had to rework the \gls{hal} a bit.
In fact, as seen in section \ref{sec:parameter-framework}, the \gls{pfw} needs \gls{xml} files which are hardware dependent.

Within the our build system, we are aware of which \gls{xml} files should be loaded, since that depends the variant we are building.
So, for each variant, we build a different package which includes the correct \gls{xml} files.
This had to be reworked into a single package.

\subsubsection{Implementation}
For an initial step, we decided to include every \gls{xml} file for all the possible variants.
The problem is that at run-time, the Stream manager (which is in the \gls{hal}) has \emph{no idea} about which configuration file
it should load for his \gls{pfw} instance.

The Stream manager need to be smarter. In order to detect what the current sound card is, we can read from \lstinline{/proc/asound} entries.
The current implementation relies on the content of \lstinline{/proc/asound/cards}.
We have a map in the Stream manager which has as key the \emph{sound card name} and as value the \gls{xml} file which should be loaded.
This is viable since there are less than five hardware variances at most for each platform.

This is just a proof of concept to show to customers that we are able to support multiple hardware variants with one single package.


% {{{2
\subsection{Fixed point parameter enhancements}
The \gls{pfw} has several kinds of parameters:
\begin{itemize}
    \item IntegerParameter
    \item BooleanParameter
    \item FixedPointParameter
    \item StringParameter
    \item EnumParameter
    \item ...
\end{itemize}

Fixed point numbers are useful for representing real numbers. Their
usage is appropriate when the processor does not haves a floating point unit
or when there is a performance gain by using them. Usually, fixed points are
represented by $Qn.m$ format, where $n$ is the \emph{Integral part} and $m$ the
\emph{Fractional part}.

The implementation of fixed point numbers in the \gls{pfw} has some
corner cases which were not correctly handled. Round issues appeared when we
were writing to a configuration file or displaying user input. To
support the expected behavior for those cases, I changed the implementation, and
wrote tests for it.

\subsubsection{Test suite in Python}

In order to verify that the new implementation was correct, I wrote a test suite
in \gls{python}. That test suite performs several checks on each fixed point. Let's
take an example to illustrate the purpose of the test suite.

Let's take the case of a $Q2.3$ number: the \emph{Integral part} is $2$ and the
\emph{Fractional part} is $3$. We can compute some specific values for that number:

TODO: explain Quantum
\begin{itemize}
    \item Quantum $2^{-3} = 0.125$
    \item UpperBound $2^2 - 0.125 = 3.875$
    \item LowerBound $-2^2 = -4$
\end{itemize}

Those values can be represented as following on figure \ref{fig:fixedPointValues}. Note that
this figure is not represented in real scale.
\begin{figureGraphics}{Fixed point special values}{fig:fixedPointValues}
    \includegraphics[width=\textwidth]{./src/img/fixedPoint.pdf}
\end{figureGraphics}

The test suite computes some values within the green(valid) area and the
red(invalid) area and performs the checks illustrated on figure \ref{fig:fixedPointTest} below.

\begin{figureGraphics}{Fixed point test suite}{fig:fixedPointTest}
    \includegraphics[height=0.6\textheight]{./src/img/fixedPointProcess.pdf}
\end{figureGraphics}

Below is a small description of the tests:
\begin{description}
    \item[Bound check] The \gls{pfw} should throw an error if we
        attempt to set an out-of-bound value.
    \item[Sanity check] If we manage to set the value, The \gls{pfw} should not modify too much
        the value. It can change by half a quantum at maximum.
    \item[Consistency check] The \gls{pfw} should accept the value it sent previously.
    \item[Bijectivity check] The \gls{pfw} should return the same value we provided it at the Consistency check.
\end{description}

\subsubsection{Rework the internal mechanism}
It was time to rework the internal
mechanism of the \gls{pfw}.

The \gls{pfw} can export parameters to a file. Fixed
point parameters can be exported as well.
\begin{itemize}
    \item When exporting them, the \gls{pfw} converts the value from
        its internal representation towards a floating point number, because that is
        easier to read.
    \item By converting that number, it also computes the amount of digits
        to use for display, or writing towards a file. This can result in
        \emph{rounding issues}, due to limitation of the \lstinline{setPrecision} \gls{cpp} method.
        TODO detail what were the issues (rounding to upper value, etc)
\end{itemize}
The fix I proposed was to replace the computation of displayable digits by something
easier, which is the \emph{Fractional part} of the fixed point number.

The example in listing \ref {lst:fixedPointProblem} illustrates a bound error check, and the output in the corrected version.

\begin{code}[language=bash, caption=$Q.2.3$ rounding issue example, label=lst:fixedPointProblem]
#  broken version  #
####################
$ pfw setParameter /Example/fixedPoint/q2.3 3.875
# Done
$ pfw getParameter /Example/fixedPoint/q2.3
# 3.9 <= this is not expected, since 3.875 is encodable!
$ pfw setParameter /Example/fixedPoint/q2.3 3.9
# Value 3.9 standing out of admitted real range
# [-4, 3.875] for FixedPointParameter /Test/test/q2.3
# ^ this is even weirder

#  fixed version  #
###################
$ pfw setParameter /Example/fixedPoint/q2.3 3.875
# Done
$ pfw getParameter /Example/fixedPoint/q2.3
# 3.875
\end{code}


% {{{2
\subsection{Multiple modem support}
With the \emph{bring your own device} trends, more and more smartphones support dual simcards. This case
is useful to use the same device for corporate and private purposes.
Besided, in some developing countries phone carriers do not cover the whole country. The habitants of those
countries need several phone carriers to use their smartphone smoothly.
For those purposes, the platform must support two modems.
Within the Intel Audio \gls{hal}, we are handling some voice processing algorithms from the signal coming from the modem.
Naturally, we have a \gls{pfw} plugin to abstract the modem. This plugin did not support multiple modems.

I had to add \emph{modem instance awareness} to the plugin. With the current implementation, it
is possible to have multiple structure files, each describing a modem. This would theoretically allow
to support as many modems as we want.

TODO explain a bit more.

% {{{1
\section{Open-sourcing on GitHub}
In order to stimulate the usage of the \gls{pfw} for other projects than the Intel Audio \gls{hal},
our team decided to release the source-code on \gls{GitHub}.
This should favor external contributions via \gls{pullrequests} and motivate
the community to use the \gls{pfw}.

Around this activity, I covered several topics:
\begin{description}
    \item[Communicating, Documentating] the \gls{pfw} components.
    \item[Push, clean, enchance] the code to make sure no proprietary
        elements are made public.
\end{description}

% {{{2
\subsection{Parameter-framework newcomer's documentation}\label{sec:tutorials}

At the start of my internship, I had to inspect the \gls{pfw}'s
source code without any documentation. The idea was to have a fresh look at
this piece of software to determine if it was open-source ready, straightforward
to use, for someone who is unfamiliar with it.

While doing that, I struggled a bit with the basic usage of the framework. The
team decided that it would be nice to have some newcomer tutorials and examples,
for an easier adoption of the open-source community. So I wrote several
tutorials:
\begin{description}
    \item[Compile and install]
        is a step-by-step guide about how to get the \gls{pfw}'s sources,
        build it and install it as a standalone on Ubuntu.
    \item[Run a simple example]
        is a how-to about running the \gls{pfw} command-line interface,
        such as \lstinline{remote-process} and \lstinline {test-platform}.  In
        this how-to, the configuration and setting files are provided so that
        the user can focus on the results. The example covers music play-list
        changing based on a user's mood.
    \item[An introduction to the .pfw language]\label{desc:pfw-language}
        is a tutorial about the .pfw language. This language was
        created to simplify the writing of settings files for the
        \gls{pfw}. Those files are then converted into \gls{xml}, which is
        the only language the \gls{pfw} understands.
\end{description}
These tutorials have been written in \gls{markdown}, the standard format used
on \gls{GitHub}.

% {{{2
\subsection{Parameter-framework's intellectual property}
Intellectual property is very important at Intel. The \gls{pfw} is released under
BSD license. All the source files must contain the correct BSD license header according
to Intel's open-source policy.

\subsubsection{license checker}
Since there are 279 source files released currently on \gls{GitHub}, it seems a lot of
work to check all those files manually.
I wrote an internal tool in \gls{python} which performs the license check semi-automatically.
The script usage is quite straightforward and showed in listing \ref{code:license}.

\begin{code}[language=bash, caption=License checker usage, label=code:license]
usage: license_updater.py [-h] [--cpp | --mk] license root_location

Scans recursively trough directories to find source code which should be
updated with a new license header.

positional arguments:
    license        the license type: ['gpl', 'bsd', 'private']
    root_location  the directory to start scanning

optional arguments:
    -h, --help     show this help message and exit
    --cpp          (default) scan for C++ files: ('h', 'c', 'hpp', 'cpp')
    --mk           scan for Android make files: .mk
\end{code}


% {{{2
\subsection{Branch sync process}\label{sec:syncProcess}
Since we work internally on the \gls{pfw} and can receive external contributions via \gls{pullrequests},
it is quite difficult to keep both repositories in sync.
On figure \ref{fig:branch-process} we can see how we plan to synchronize the different code.

\begin{figureGraphics}{Final branch process}{fig:branch-process}
    \includegraphics[width=\textwidth]{./src/img/branches-process.pdf}
\end{figureGraphics}


% {{{2
\subsection{Alsa plugin refactoring}
The Alsa plugin is used to handle \gls{alsa} (for desktop mostly) or TinyAlsa (for embedded \gls{android} devices mostly) subsystems.
For our internal uses, we patched some \gls{aosp} projects such as TinyAlsa which allows us to support proprietary controls.
The support of such controls was also implemented in the \gls{alsa} \gls{pfw} plugin. Since
we want to open-source the plugin, those proprietary features should be removed.

During the removal of those special controls, we also simplified the plugin
architecture by merging the controls and the mixer code. TODO removing templates.
The result is a far simpler design.
TODO detail.

% {{{2
\subsection{Code alignment}

When I had to update the different components on \gls{GitHub}, there were some issues:
Our internal version and the \gls{GitHub} one had diverged.
On figure \ref{fig:diverged}, we can see an overview of the branch state before I reworked them.

\begin{figureGraphics}{Repository divergence}{fig:diverged}
    \includegraphics[width=\textwidth]{./src/img/branch-divergence.pdf}
\end{figureGraphics}
Since all the components I uploaded on \gls{GitHub} had modifications which weren't present
in the internal source tree, I encountered the divergence issue for each project I
synchronized with \gls{GitHub} (Core, Alsa and Filesystem).

This was a very good exercise to improve my \gls{git} skill.

\subsection{Core upload}
The \gls{pfw} core is quite a big project, with about 30 000 lines of code.
Align the internal tree and the \gls{GitHub} version of this project required quite some work.
Some extra requirements apply on open-source projects, such as being compilable in a vanilla \gls{aosp} environment.

There is a \gls{GitHub} organization which groups all Intel open-source projects. This
organization is called \emph{01org}. I joined it during my internship in order to have admin rights
on the projects I had to open-source.

The \gls{pfw} core is available on \gls{GitHub}\footnote{\url{https://github.com/01org/parameter-framework}}

% {{{2
\subsection{Filesystem plugin upload}

The file system plugin is used for global access to the filesystem. This can be to
use \emph{/proc} entries for instance. I used this plugin as example in the rookie
documentation I wrote as described in section \ref{sec:tutorials}.

I also worked on an other example: \emph{controlling lEDS} via the filesystem
plugin on a Raspberry Pi.  This example was easy enough to be integrated into
the online documentation of the filesystem plugin, on \gls{GitHub}.

The filesystem plugin is available on \gls{GitHub}\footnote{\url{https://github.com/01org/parameter-framework-plugins-filesystem/}}

% {{{2
\subsection{Alsa plugin upload}

The \gls{alsa} \gls{pfw} plugin is used on within the Intel Audio \gls{hal}. It can also by used
on a linux desktop environement to handle \gls{alsa} mixers.

To demonstrate the power of this plugin, I wrote the README file which is on the
front page on this \gls{GitHub} project.  The README contains :
\begin{itemize}
    \item Build and install instructions
    \item Prerequisites for using this plugin
    \item A tutorial which details how to write the \gls{xml} files for this
    plugin in order to be able to change the master volume on a linux desktop.
\end{itemize}
I also reorganised some code within this plugin since we used to rely on proprietary \gls{aosp} modifications.
This plugin is now vanilla \gls{aosp} compatible, and can be used if the \gls{pfw} is installed.

The \gls{alsa} plugin is available on \gls{GitHub}\footnote{\url{https://github.com/01org/parameter-framework-plugins-alsa/}}
